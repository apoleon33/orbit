import 'dart:io';

import 'package:http/http.dart' as http;
import 'package:image/image.dart' as img;
import 'package:orbit/display/display.dart';
import 'package:orbit/display/requestless_display.dart';
import 'package:orbit/track.dart';
import 'package:tint/tint.dart';

import 'package:colorgram/colorgram.dart';

class Interface extends Display implements RequestlessDisplay {
  Track? _currentTrack;

  /// How many lines the display of the current song takes in the terminal.
  final int nowPLayingLineNumber = 8;

  /// How many lines the "no music detected" text takes in the terminal.
  final int notPlayingLineNumber = 1;

  final String leftPadding = "   ";

  final int coverDimensions = 20; // in pixel

  final String delimiter = "------------------------";

  Interface(super.api);

  /// Returns a string colored like the ones given in arguments
  String createColorPalette(List<CgColor> colors, {String char = "███"}) =>
      colors
          .map(
            (color) => color.percentage
                .toStringAsFixed(2)
                .replaceAll(
                  RegExp("0.00"),
                  char.rgb(r: color.r, g: color.g, b: color.b),
                ) // weird workaround to avoid percentages on cover
                .onRgb(r: color.r, g: color.g, b: color.b),
          )
          .join();

  // generated by Gemini
  void _clearTerminal() {
    if (Platform.isWindows) {
      // This is a common way to clear the screen on Windows
      // by executing the `cls` command.
      try {
        Process.runSync('cmd', ['/c', 'cls'], runInShell: true);
      } catch (e) {
        // Fallback for older Windows terminals or systems where `cmd` is not easily accessible.
        print('\x1B[2J\x1B[0;0H');
      }
    } else {
      // For Linux, macOS, and modern terminals.
      // The ANSI escape sequence for clearing the screen.
      print('\x1B[2J\x1B[0;0H');
    }
  }

  Future<List<String>?> convertImgToAscii(Track track) async {
    try {
      final response = await http.get(
        Uri.parse(
          track.image
              .where((img) => img.imageSize == ImageSize.extralarge)
              .toList()[0]
              .url,
        ),
      );

      if (response.statusCode == 200) {
        // Décoder l'image en mémoire
        img.Image? image = img.decodeImage(response.bodyBytes);
        if (image != null) {
          img.Image resizedImage = img.copyResize(
            image,
            width: coverDimensions,
            height: coverDimensions,
          );

          List<List<CgColor>> colors = List.empty(growable: true);

          for (var y = 0; y < coverDimensions; y++) {
            colors.add([]);

            for (var x = 0; x < coverDimensions; x++) {
              img.Pixel currentPixel = resizedImage.getPixel(x, y);

              colors[y].add(
                CgColor(
                  currentPixel.r.toInt(),
                  currentPixel.g.toInt(),
                  currentPixel.b.toInt(),
                  0.0,
                  //(1 / (coverDimensions * coverDimensions)) * 100,
                ),
              );
            }
          }

          return colors
              .map((elem) => createColorPalette(elem, char: "▓▓"))
              .toList();
        }
      }
    } catch (e) {
      print('Erreur: $e');
      return null;
    }
    return null;
  }

  Future<String> formatOutput(Track track) async {
    List<CgColor> dominantColors = (await getColorPalette(
      track.image
          .where((img) => img.imageSize == ImageSize.extralarge)
          .toList()[0]
          .url,
    ))!;

    List<String> albumCover = (await convertImgToAscii(track))!;

    // let's avoid making one long line
    String output = "$leftPadding${albumCover[0]}";
    output += "$leftPadding${"Music detected!".bold().red()}\n";
    output += "$leftPadding${albumCover[1]}";
    output += "$leftPadding${"Name".bold().red()}: ${track.name.italic()}\n";
    output += "$leftPadding${albumCover[2]}";
    output +=
        "$leftPadding${"Album".bold().red()}: ${track.album.name.italic()}\n";
    output += "$leftPadding${albumCover[3]}";
    output +=
        "$leftPadding${"Artist".bold().red()}: ${track.artist.name.italic()}\n";
    output += "$leftPadding${albumCover[4]}";
    output +=
        "$leftPadding${"Image".bold().red()}: ${track.image.last.url.substring("https://lastfm.freetls.fastly.net/i/u/300x300/".length)}\n";
    output += "$leftPadding${albumCover[5]}";
    output += "$leftPadding${createColorPalette(dominantColors)}\n";
    output += "$leftPadding${albumCover[6]}";
    output += "$leftPadding$delimiter\n";
    output += "$leftPadding${albumCover[7]}";
    output +=
        "$leftPadding${"LastFM Username".bold().red()}: ${api.username}\n";
    output += "$leftPadding${albumCover[8]}";
    output +=
        "$leftPadding${"Total account scrobbles".bold().red()}: ${await api.totalScrobble}\n";

    for (var row in albumCover.sublist(nowPLayingLineNumber)) {
      output += "$leftPadding$row\n";
    }

    return output;
  }

  @override
  Future<void> display() async {
    final Track lastTrack = await api.getLastTrack();

    bool nowPlayingStatus = await api.isUserNowPlaying();

    if (nowPlayingStatus) {
      // if (lastTrack != _currentTrack) {
      //  reload the whole display only when the track changes

      _clearTerminal();
      print((await formatOutput(lastTrack)));

      _currentTrack = lastTrack;
    } else {
      _clearTerminal();
      print("no music currently playing, retrying in 15s...".bold().blue());
    }
  }

  @override
  Future<void> show(Track track) {
    // TODO: implement show
    throw UnimplementedError();
  }
}
