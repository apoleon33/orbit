import 'dart:io';

import 'package:orbit/display/display.dart';
import 'package:orbit/track.dart';
import 'package:tint/tint.dart';

import 'package:colorgram/colorgram.dart';

class Interface extends Display {
  Track? _currentTrack;

  /// How many lines the display of the current song takes in the terminal.
  final int nowPLayingLineNumber = 6;

  /// How many lines the "no music detected" text takes in the terminal.
  final int notPlayingLineNumber = 1;

  Interface(super.api);

  /// Returns a string colored like the ones given in arguments
  String createColorPalette(List<CgColor> colors) => colors
      .map((color) => "███".rgb(r: color.r, g: color.g, b: color.b))
      .join();

  // generated by Gemini
  void _clearTerminal() {
    if (Platform.isWindows) {
      // This is a common way to clear the screen on Windows
      // by executing the `cls` command.
      try {
        Process.runSync('cmd', ['/c', 'cls'], runInShell: true);
      } catch (e) {
        // Fallback for older Windows terminals or systems where `cmd` is not easily accessible.
        print('\x1B[2J\x1B[0;0H');
      }
    } else {
      // For Linux, macOS, and modern terminals.
      // The ANSI escape sequence for clearing the screen.
      print('\x1B[2J\x1B[0;0H');
    }
  }

  Future<String> formatOutput(Track track) async {
    List<CgColor> dominantColors = (await getColorPalette(
      track.image
          .where((img) => img.imageSize == ImageSize.extralarge)
          .toList()[0]
          .url,
    ))!;

    // let's avoid making one long line
    String output = "Music detected!\n".bold();
    output += "${"Name".bold()}:               ${track.name.italic()}\n";
    output += "${"Album".bold()}:              ${track.album.name.italic()}\n";
    output += "${"Artist".bold()}:             ${track.artist.name.italic()}\n";
    output += "${"Image".bold()}:              ${track.image.last.url}\n";
    output +=
        "${"Dominant colors".bold()}:    ${createColorPalette(dominantColors)}";

    return output;
  }

  @override
  Future<void> display() async {
    final Track lastTrack = await api.getLastTrack();

    bool nowPlayingStatus = await api.isUserNowPlaying();

    if (nowPlayingStatus) {
      if (lastTrack != _currentTrack) {
        //  reload the whole display only when the track changes

        _clearTerminal();
        print((await formatOutput(lastTrack)).blue());

        _currentTrack = lastTrack;
      }
    } else {
      _clearTerminal();
      print("no music currently playing, retrying in 15s...".bold().blue());
    }
  }
}
